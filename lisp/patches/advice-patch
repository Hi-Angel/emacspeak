diff --git a/lisp/emacspeak-preamble.el b/lisp/emacspeak-preamble.el
index 6e8fae032..b3ea1d5c0 100644
--- a/lisp/emacspeak-preamble.el
+++ b/lisp/emacspeak-preamble.el
@@ -144,44 +144,36 @@
 (defvar ems-called-interactively-p nil
   "Record interactive calls to advised functions.")
 
-(defun ems-record-interactive-p (f)
-  "Predicate to test if we  record interactive calls.
- Memoizes result  via property 'emacspeak."
-  (cond
-   ((not (symbolp f)) nil)
-   ((get f 'emacspeak) t) ; already memoized
-   ((ad-find-some-advice f 'any  "emacspeak");emacspeak advice present
-    (put f 'emacspeak t)); memoize and return t
-   (t nil)))
-
 (defadvice funcall-interactively (around emacspeak  pre act comp)
   "Set emacspeak  interactive flag if there is an advice."
-  (let ((ems-called-interactively-p ems-called-interactively-p)) ; save state
-    (when (ems-record-interactive-p (ad-get-arg 0))
-      (setq ems-called-interactively-p (ad-get-arg 0)))
+  (let ((ems-called-interactively-p (ad-get-arg 0)))
     ad-do-it))
 
 (defadvice call-interactively (around emacspeak  pre act comp)
   "Set emacspeak  interactive flag if there is an advice."
-  (let ((ems-called-interactively-p ems-called-interactively-p))
-    (when (ems-record-interactive-p (ad-get-arg 0))
-      (setq ems-called-interactively-p (ad-get-arg 0)))
+  (let ((ems-called-interactively-p (ad-get-arg 0)))
     ad-do-it))
 
-(defsubst ems-interactive-p ()
-  "Check  interactive flag.
-Return T if set and we are called from the advice for the current
- command. Turn off the flag once used."
-  (when ems-called-interactively-p      ; interactive call
-    (let ((caller (cl-second (backtrace-frame 1))) ; containing function name
-          (caller-advice ; advice wrapper of containing function
-           (ad-get-advice-info-field ems-called-interactively-p  'advicefunname))
-          (result nil))
-                                        ; T if called from our advice
-      (setq result (eq caller caller-advice))
-      (when result
-        (setq ems-called-interactively-p nil) ; turn off now that we used  it
-        result))))
+(advice-add 'defadvice :around #'ems--define-interactive-p)
+(defun ems--define-interactive-p (orig-mac funname args &rest body)
+  "Lexically redefine `ems-interactive-p' within BODY.
+The local definition expands to a call to `ems--interactive-p' to which it
+passes FUNNAME as argument."
+  (apply orig-mac funname args
+         (macroexp-unprogn
+          (macroexpand-all (macroexp-progn body)
+                           `((ems-interactive-p
+                              . ,(lambda () `(ems--interactively-p ',funname)))
+                             . ,macroexpand-all-environment)))))
+
+(defmacro ems-interactive-p ()
+  (error "ems-interactive-p used outside of defadvice!"))
+
+(defun ems--interactive-p (funname)
+  "Return non-nil if we're within an interactive call of FUNNAME."
+  (when (eq ems-called-interactively-p funname)
+    (setq ems-called-interactively-p nil) ; Turn off now that we used  it.
+    t))
 
 ;;}}}
 ;;{{{defsubst: ems--fastload:
